%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Programming/Coding Assignment
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing assignment content.
%
% This template uses a Perl script as an example snippet of code, most other
% languages are also usable. Configure them in the "CODE INCLUSION 
% CONFIGURATION" section.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
%\usepackage{graphicx}% % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{courier} % Required for the courier font
 \usepackage[pdftex]{graphicx}
  \graphicspath{{figures/}}
   \DeclareGraphicsExtensions{.pdf,.jpg,.png}
  \usepackage[caption=false,font=footnotesize]{subfig}
%\usepackage[cmex10]{amsmath}
\usepackage{amsmath,amssymb}
\interdisplaylinepenalty=2500
\usepackage{afterpage}
\newcommand\blankpage{%
    \null
    \thispagestyle{empty}%
    \addtocounter{page}{-1}%
    \newpage}


% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
%\chead{\hmwkClass\ (\hmwkClassInstructor\ \hmwkClassTime): \hmwkTitle} % Top center head
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	CODE INCLUSION CONFIGURATION
%----------------------------------------------------------------------------------------
%
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}


%----------------------------------------------------------------------------------------
%	DOCUMENT STRUCTURE COMMANDS
%	Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

%% Header and footer for when a page split occurs within a problem environment
\newcommand{\enterProblemHeader}[1]{
\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

% Header and footer for when a page split occurs between problem environments
\newcommand{\exitProblemHeader}[1]{
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1}{}\nobreak
}

\setcounter{secnumdepth}{0} % Removes default section numbers
\newcounter{homeworkProblemCounter} % Creates a counter to keep track of the number of problems
\setcounter{homeworkProblemCounter}{0}
\newcommand{\homeworkProblemName}{}
\newenvironment{homeworkProblem}[1][Section \arabic{homeworkProblemCounter}]{ % Makes a new environment called homeworkProblem which takes 1 argument (custom name) but the default is "Problem #"
\stepcounter{homeworkProblemCounter} % Increase counter for number of problems
\renewcommand{\homeworkProblemName}{#1} % Assign \homeworkProblemName the name of the problem
\section{\homeworkProblemName} % Make a section in the document with the custom problem count
\enterProblemHeader{\homeworkProblemName} % Header and footer within the environment
}{
\exitProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

\newcommand{\problemAnswer}[1]{ % Defines the problem answer command with the content as the only argument
\noindent\framebox[\columnwidth][c]{\begin{minipage}{0.98\columnwidth}#1\end{minipage}} % Makes the box around the problem answer and puts the content inside
}

\newcommand{\homeworkSectionName}{}
\newenvironment{homeworkSection}[1]{ % New environment for sections within homework problems, takes 1 argument - the name of the section
\renewcommand{\homeworkSectionName}{#1} % Assign \homeworkSectionName to the name of the section from the environment argument
\subsection{\homeworkSectionName} % Make a subsection with the custom name of the subsection
\enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]} % Header and footer within the environment
}{
\enterProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

%----------------------------------------------------------------------------------------
%	NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Coursework \#2} % Assignment title
\newcommand{\hmwkDueDate}{Friday,\ March 20,\ 2016} % Due date
\newcommand{\hmwkClass}{COMPM080} % Course/class
\newcommand{\hmwkAuthorName}{Maria Ruxandra Robu} % Your name

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
\vspace{2in}
\textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
\normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate}\\
%\vspace{0.1in}\large{\textit{\hmwkClassInstructor\ \hmwkClassTime}
\vspace{3in}
}

\author{\textbf{\hmwkAuthorName  - 14042500}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC

%\newpage
%\tableofcontents
\newpage

\textbf{Introduction}\\

The section Discrete Curvature introduces different methods to discretize the Laplacian operator on a mesh. The mean curvature H, Gaussian curvature K and the principal curvatures k1 and k2 are implemented and visualized. These have been obtained from both a uniform Laplacian and a Laplace Beltrami operator.\\


The section Laplacian Smoothing shows results for explicit and implicit smoothing of a mesh on a simple cube and a more complex shape. It also discusses smoothing operations in the context of mesh denoising.


%----------------------------------------------------------------------------------------
%	PROBLEM 1
%----------------------------------------------------------------------------------------

% To have just one problem per page, simply put a \clearpage after each problem

\begin{homeworkProblem}[Section 1 - Discrete Curvature]

The colour mapping used throughout this section is: 
\begin{itemize}
\item blue for negative values
\item black for values close to 0
\item red for positive values
\end{itemize}

\textbf{1. Uniform Laplacian and mean curvature}\\

The uniform Laplacian operator is implemented after the equation \ref{eq:unifLaplac}.
\begin{equation}
\label{eq:unifLaplac}
\Delta f(v_i) = \frac{1}{|N(v_i)|} * \sum_{v_j \in N(v_i))}(v_j - v_i)
\end{equation}

After the second derivative is computed at each vertex in the mesh, the mean curvature can be approximated. The mean curvature is in the opposite direction of the normal, so the vertex normals are needed for its estimation. The normals have been computed in MeshLab and imported with the mesh.

\begin{equation}
\Delta f = -2Hn
\end{equation}

\begin{equation}
 H(v_i) = \frac{1}{2}  <\Delta f(v_i), n(v_i)>
\end{equation}

A scalar value is obtained for each vertex for the mean curvature. Figure \ref{fig:meanCurv} shows the results for the dragon mesh. \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[!h]
\centering
\subfloat[]{\includegraphics[height=2.5 in]{meanCurv1}%
\label{fig_meanCurvUL1}}
\hfil
\subfloat[]{\includegraphics[height=2.5 in]{meanCurv2}%
\label{fig_meanCurvUL2}}
\vfil
\subfloat[]{\includegraphics[height=2.5 in]{meanCurvLB1}%
\label{fig_meanCurvLB1}}
\hfil
\subfloat[]{\includegraphics[height=2.5 in]{meanCurvLB2}%
\label{fig_meanCurvLB2}}
\caption{Mean Curvature: Top Row - Uniform Laplace; Bottom Row - Laplace Beltrami}
\label{fig:meanCurv}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\textbf{2. Gaussian curvature and the principal curvatures}\\

The Gaussian curvature is obtained by computing the angle deficit around each vertex. Figure \ref{fig:gaussianCurv} illustrated the values for the Gaussian curvature on the dragon mesh. As expected, the red values appear in elliptical areas (tips of scales), whereas the blue ones in hyperbolic areas (in saddles). The areas that can be approximated with a plane locally appear as black, with values close to 0.

 \begin{equation}
 K(v_i) = \frac{1}{A(v_i)} (2 \pi - \sum_{j \in N(v_i)} \theta_j) 
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[!h]
\centering
\subfloat[]{\includegraphics[height=2.5 in]{gaussianCurv1}%
\label{fig_gaussianCurv1}}
\hfil
\subfloat[]{\includegraphics[height=2.5 in]{gaussianCurv2}%
\label{fig_gaussianCurv2}}
\caption{Gaussian Curvature}
\label{fig:gaussianCurv}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Once the mean and Gaussian curvature have been computed, the principal curvatures k1 and k2 can be calculated using equation \ref{eq:princCurv}.

 \begin{equation}
 H = \frac{k_1 + k_2}{2}
\end{equation}

 \begin{equation}
 K = k_1 k_2
\end{equation}

 \begin{equation}
 \label{eq:princCurv}
 k_{1,2} = H \pm \sqrt{H^2 - K}
\end{equation}

If the difference under the square root is not positive, the principal curvatures are set to 0. Figure \ref{fig:prinCurv} shows the results for the principal curvatures obtained through the uniform Laplacian versus the ones obtained with the cotangent discretization. The right column shows a better representation of the surface by introducing more detail. \\


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[!h]
\centering
\subfloat[]{\includegraphics[height=2 in]{k1_ul}%
\label{fig_k1ul}}
\hfil
\subfloat[]{\includegraphics[height=2 in]{k1_lb}%
\label{fig_k1lb}}
\vfil
\subfloat[]{\includegraphics[height=2 in]{k2_ul}%
\label{fig_k2ul}}
\hfil
\subfloat[]{\includegraphics[height=2 in]{k2_lb}%
\label{fig_k2lb}}
\caption{Principal Curvatures: a) Maximum curvature - Uniform Laplacian; b) Maximum curvature - Non-uniform Laplacian; c) Minimum curvature - Uniform Laplacian; b) Minimum curvature - Non-uniform Laplacian }
\label{fig:prinCurv}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\textbf{4. Discrete Laplace-Beltrami}\\

The Laplace Beltrami operator is computed using the cotangents of the adjacent angles to a neighbouring vertex as weights. 

\begin{equation}
\Delta _s f(v) = \frac{1}{2* A(v_i) }* \sum_{v_j \in N(v_i)}(cotan (\beta_i) + cotan(\alpha_i))(v_j - v_i)
\end{equation}

 \begin{equation}
cotan (\alpha) = \frac{<edge1, edge2>} {|| edge1 \wedge edge2 ||}, where || edge1|| = || edge2 ||  = 1
\end{equation}

The operator is normalized by the area of the barycentric cells, which is 1/3 of the area of a neighbouring triangle.
\begin{equation}
A(v_i,v_j,v_{j+1})= \frac{1}{6}|| (v_j - v_i) \wedge (v_{j+1} - v_i)||
\end{equation}

The mean curvature was recomputed using the Laplace Beltrami operator and the results are shown in figure \ref{fig:meanCurv}. The surface is better represented as the angles surrounding a vertex and the corresponding areas are taken into consideration. For example, flat areas have more values closer to 0 (black), as they should. The principal curvatures have been recalculated and the results are shown in figure \ref{fig:prinCurv}, in the right column.

\end{homeworkProblem}
\clearpage
%\clearpage
%----------------------------------------------------------------------------------------
%	PROBLEM 2
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}[Section 2 - Laplacian Mesh Smoothing]

\textbf{5. Explicit Laplacian Smoothing}\\

Explicit Laplacian Smoothing was implemented using the equation \ref{eq:explicitSm}, iteratively, for each vertex in the mesh:

\begin{equation}
\label{eq:explicitSm}
v_i  = v_i + \lambda \Delta (v_i)
\end{equation}

The results for different lambdas and numbers of iterations are presented in figures \ref{fig:explicitSm}. From my experiments, values for  $\lambda$ that are bigger than 1 start adding noise to the initial mesh, like in figure \ref{fig_explicitL2}. \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[!h]
\centering
\subfloat[]{\includegraphics[height=2 in]{explicitL1_5iter}%
\label{fig_explicitL5}}
\hfil
\subfloat[]{\includegraphics[height=2 in]{explicitL1_5iter_diff}%
\label{fig_explicitL5_diff}}
\vfil
\subfloat[]{\includegraphics[height=2 in]{explicitL2_3iter}%
\label{fig_explicitL2}}
\hfil
\subfloat[]{\includegraphics[height=2 in]{explicitL2_3iter_diff}%
\label{fig_explicitL2_diff}}
\caption{Explicit Smoothing: a) Lambda = 1, Iterations = 5; b) Difference between the smoothed (yellow) and original (white) mesh; c) Lambda = 2, Iterations = 3; d) Difference between the smoothed (yellow) and original (white) mesh}
\label{fig:explicitSm}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textbf{6. Implicit Laplacian Smoothing}\\

This restriction can be removed by implementing implicit smoothing. Instead of increasing the smoothing incrementally in small steps, this formulation allows bigger jumps by choosing higher values for $\lambda$.

\begin{equation}
(I - \lambda \Delta) v_{i+1} = v_{i}
\end{equation}

The implicit smoothing equation was solved using the bi conjugate gradient stabilized solver (Eigen::BiCGSTAB). Figure \ref{fig:implicitSm} shows results for various setting. As opposed to the explicit smoothing, this implementation does not introduce noise and allows for a more stable result.

%\begin{equation}
%\tilde{p} = p - \bar{p}
%\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[!h]
\centering
\subfloat[]{\includegraphics[height=2.5 in]{implicitL5_1iter}%
\label{fig_implicitL5}}
\hfil
\subfloat[]{\includegraphics[height=2.5 in]{implicitL5_1iter_diff}%
\label{fig_implicitL5_diff}}
\vfil
\subfloat[]{\includegraphics[height=2.5 in]{implicitL3_3iter}%
\label{fig_implicitL3}}
\hfil
\subfloat[]{\includegraphics[height=2.5 in]{implicitL3_3iter_diff}%
\label{fig_implicitL3_diff}}
\caption{Implicit Smoothing: a) Lambda = 5, Iterations = 1; b) Difference between the smoothed (pink) and original (white) mesh; c) Lambda = 3, Iterations = 3; d) Difference between the smoothed (pink) and original (white) mesh}
\label{fig:implicitSm}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[!h]
\centering
\subfloat[]{\includegraphics[height=2.5 in]{explicitL05_3iter}%
\label{fig_explicitCube}}
\hfil
\subfloat[]{\includegraphics[height=2.5 in]{implicitCube_L3_3iter}%
\label{fig_implicitCube}}
\caption{Cube - Explicit vs. Implicit Smoothing: a) Lambda = 0.5, Iterations = 3; b) Lambda = 3, Iterations = 3 }
\label{fig:cube}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

These smoothing algorithms have been applied to both simple and complex meshes. Figure \ref{fig:cube} shows the results for a cube. Only the edges have been shown from the original mesh, to provide a comparison to the smoothed cubes. In this case, $\lambda$ has to have even smaller values for the explicit smoothing. If $\lambda = 1$, the cube gets very small and it loses its shape. \\


These smoothing algorithms have been implemented based on the uniform discretization of the Laplacian. This implementation choice is obvious in the context of the cube, where smoothing makes the object deform. A better approach would be to use the cotangent discretization. Since the Laplace Beltrami operator incorporates information about the normals, the smoothing would preserve more of the initial shape of the objects. \\

\clearpage
\textbf{7. Denoising experiments}\\

Gaussian noise with mean 0 and standard deviation of 0.001 was added to the dragon mesh. The challenge in using Laplacian smoothing to denoise a mesh is in removing the noise whilst at the same time, keeping the high frequency details. Figures \ref{fig:noisy} and \ref{fig:noisy2} show some results for different parameters. Lambda was chosen to be lower than 1 in all the experiments with explicit smoothing, since higher values add more noise. Figures \ref{fig:noisy} b) and d) show a smooth mesh, with loss in the details around the scales and the head of the dragon. \\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[!h]
\centering
\subfloat[]{\includegraphics[height=2 in]{noisyDragon}%
\label{fig_noisyDragonOrig}}
\hfil
\subfloat[]{\includegraphics[height=2 in]{noisyExplL1_5iter}%
\label{fig_implicitCube}}
\vfil
\subfloat[]{\includegraphics[height=2 in]{noisyImplL3_1iter}%
\label{fig_noisyDragonOrig}}
\hfil
\subfloat[]{\includegraphics[height=2 in]{noisyImplL3_3iter}%
\label{fig_implicitCube}}
\caption{ Experiments with noise: a) Noise with std = 0.001 was added to the dragon mesh; b) Explicit Smoothing - $\lambda = 1$, iterations = 5; c) Implicit Smoothing - $\lambda = 3$, iterations = 1; d) Implicit Smoothing - $\lambda = 3$, iterations = 3}
\label{fig:noisy}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In order to decrease the loss of details, further setting were tried for the smoothing. Figures \ref{fig:noisy2}a) and b) show that examples in which the noise is still present after smoothing. \\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[!h]
\centering
\subfloat[]{\includegraphics[height=2 in]{noisyExplL1_3iter}%
\label{fig_noisyDragonOrig}}
\hfil
\subfloat[]{\includegraphics[height=2 in]{noisyExplL2_2iter}%
\label{fig_implicitCube}}
\vfil
\subfloat[]{\includegraphics[height=2 in]{noisyExplL07_5iter}%
\label{fig_noisyDragonOrig}}
\hfil
\subfloat[]{\includegraphics[height=2 in]{noisyImplL2_5iter}%
\label{fig_implicitCube}}
\caption{ Experiments with noise: a) Explicit Smoothing - $\lambda = 1$, iterations = 3;  b) Implicit Smoothing - $\lambda = 2$, iterations = 2; c) Explicit Smoothing - $\lambda = 0.7$, iterations = 5; d) Implicit Smoothing - $\lambda = 2$, iterations = 5}
\label{fig:noisy2}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In conclusion, depending on the amount of noise present, Laplacian smoothing can be used to retrieve the original shape, to some extent. Experiments have to be conducted in order to find the optimal parameters that would recover enough of the high frequency details, whilst removing a reasonable amount of noise. From the above experiments, lower values of lambda with a higher number of iterations lead to better results. However, this would increase the computation time since each iteration goes through the whole mesh.

\end{homeworkProblem}

%----------------------------------------------------------------------------------------
%\afterpage{\blankpage}
\clearpage
\bibliographystyle{ieeetr}
\bibliography{ap3dgLIB}

\end{document}